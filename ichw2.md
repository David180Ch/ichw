# # 1、停机问题

# 为什么要证明停机问题
图灵证明停机问题证明了程序并不是无所不能的，一切程序应基于逻辑合理的设定。

# 证明的方法
假设存在程序A，A能判定任何程序是否会在某一给定输入时停机
现在设计程序B，B的运行原理如下
向B输入一个程序C，若C在输入D时被A判定为将会停机，则B不停机
否则B停机

那么如果说A调用的程序是B，输入B的程序也是B会发生什么呢
我们发现，若A判断B会停机，则B在输入B后不应该停机
若A判断B不会停机，则B在输入B后应该停机
无论何种A的判断结果输出最终都将与B的行为矛盾，因此停机程序A不存在

# 证明的数学原理
哥德尔不完备性定理，存在命题既不能被证实也不能被证伪，如只由初等数论构成的自洽代数公理系统。一个将自身结果作为判定条件的自指命题可能是悖论。

# # 2、二进制补码
# 补码的意义：补码的意义：使计算机能够仅通过执行加法运算便进行减法，联想中学概念，加一个数等于减去它的相反数，这里我们不妨设相反数=补码，现在开始介绍

    计算机的二进制代码中并不存在负数，也就是任何一串数字都只用一串0和1的编码进行，这里，重要的一点是存在一个上限，例如8位代码中，1111_1111（b）为最大储存代码，多余则溢出，溢出部分不计，如1111_1111（b）+0000_0001（b）= 0000_0000(b),我们可以类比时钟，假设现在时间是九点钟，我们想要将时间拨回4个小时，而对于时钟盘，12个小时便是存储上限，因此我们既可以拨回四个小时——虽然计算机并不能直接作减，但是我们也可以向前拨8个小时——9+8=12（溢出部分）+5（最终输出结果），可见两种算法都能获得同一显示结果。而在我们刚才的操作中，8便是4对应的补码，也便是用上限（或是一周）的12减去4得到的。因为9-4=5在这个里面变成了9+（-4）=9+（8-12）=9+8-12，而减12则是由系统本身存在溢出上限而自然得到的结果。
    现在我们知道了补码的工作原理，便可以通过此得到补码了。首先取一个数，如-15（d），首先取其正数部分的二进制0000_1111（b），将符号位（也便是最高位）变为1（因为正数最高位符号为0，与负数补码1相加后才能正常溢出），接下来各位依次取反，可以看到取反后的代码1111_0000（b）与原码相加只能得到1111_1111的结果，因此我们需要将补码再加上1，这样补原码相加正好可以正常溢出为0000_0000了，也便是时针转过一周，而其也可以运用在减法运算中了。
    
# # IEEE754    
0：* 0000 0000 000 0000
±1.0：* 0111 1111 000 0000
最大非规范数：* 0000 0000 111 1111
最小非规范数：* 0000 0000 000 0001 
最大规范化浮点数：* 1111 1110 111 1111
最小规范化浮点数：* 0000 0001 000 0000
无穷：* 1111 1111 0000 0000
NaN：* 1111 1111 non zero
